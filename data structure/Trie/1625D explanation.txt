// https://codeforces.com/blog/entry/99031?#comment-877921

let's give it a trie.
this is my solution which is a little different than the one in the editorial.
First, let's focus on the MSB of K and try to group the number based on bits starting from the MSB position to the end. for example, if we have K=00010101
so we're interested in the prefix part till the first 1 bit, split k like that.
0001 | 0101
and we split numbers at the same position to height bits and lowest bits
0110 | 1000
0110 | 1001
1010 | 1100
1011 | 1010
0001 | 1001
0111 | 1000
group numbers by the first part.

observation-1 look at the left part (highest bits) if this part is equal then XOR will be zero and it's bad as it will make our XOR lower than K, so the max we can get from this group is only one element.
observation-2 if the left part only differs at the lowest bit then we can get one element from each group, we just need to know that the XOR between these two elements is >=K and we can do this using trie (later I will explain how).
observation-3 if the bits are different then it's guaranteed that it will produce a number greater than K.
so getting to the Trie part, the trie is only needed in observation two, if we found two numbers have the same prefix and differ only in the first bit.
so to check that we're checking two groups A, B and trying to find if we have any two pairs that have XOR >=k. put all the numbers in group A in a trie, our binary trie will have left as zero bit, right as 1 bit. now iterate over numbers in group B, for each number try to find the MAX XOR you can get, basically you iterate over the bits in this number from left to write and try to go to the opposite if possible.
if the current bit is 1 then try to go to 0 in the trie (this will maximize the XOR value).